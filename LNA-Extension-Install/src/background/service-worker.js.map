{"version":3,"file":"service-worker.js","sources":["../../../src/api/google-drive.ts","../../../src/api/onedrive.ts","../../../src/background/service-worker.ts"],"sourcesContent":["/**\n * Living Nexus Archive - Google Drive API Integration\n */\n\nimport type { CloudFile, AuthToken } from '../types';\n\nconst GOOGLE_DRIVE_API_BASE = 'https://www.googleapis.com/drive/v3';\n\nexport class GoogleDriveAPI {\n  private accessToken: string | null = null;\n\n  /**\n   * Authenticate with Google Drive using Chrome Identity API\n   */\n  async authenticate(): Promise<AuthToken> {\n    return new Promise((resolve, reject) => {\n      chrome.identity.getAuthToken({ interactive: true }, (token) => {\n        if (chrome.runtime.lastError || !token) {\n          reject(new Error(chrome.runtime.lastError?.message || 'Authentication failed'));\n          return;\n        }\n\n        this.accessToken = token;\n        \n        resolve({\n          provider: 'google-drive',\n          accessToken: token,\n          expiresAt: Date.now() + 3600000 // 1 hour\n        });\n      });\n    });\n  }\n\n  /**\n   * Get all files from Google Drive\n   */\n  async getAllFiles(): Promise<CloudFile[]> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated. Call authenticate() first.');\n    }\n\n    const files: CloudFile[] = [];\n    let pageToken: string | undefined;\n\n    do {\n      const response = await this.fetchFiles(pageToken);\n      files.push(...response.files);\n      pageToken = response.nextPageToken;\n    } while (pageToken);\n\n    return files;\n  }\n\n  /**\n   * Fetch a page of files from Google Drive\n   */\n  private async fetchFiles(pageToken?: string): Promise<{ files: CloudFile[]; nextPageToken?: string }> {\n    const params = new URLSearchParams({\n      pageSize: '1000',\n      fields: 'nextPageToken, files(id, name, mimeType, size, createdTime, modifiedTime, webViewLink, thumbnailLink, parents)',\n      q: \"trashed = false\"\n    });\n\n    if (pageToken) {\n      params.append('pageToken', pageToken);\n    }\n\n    const response = await fetch(`${GOOGLE_DRIVE_API_BASE}/files?${params}`, {\n      headers: {\n        'Authorization': `Bearer ${this.accessToken}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Google Drive API error: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n\n    const files: CloudFile[] = data.files.map((file: any) => ({\n      id: file.id,\n      name: file.name,\n      mimeType: file.mimeType,\n      size: parseInt(file.size || '0'),\n      createdTime: file.createdTime,\n      modifiedTime: file.modifiedTime,\n      webViewLink: file.webViewLink,\n      thumbnailLink: file.thumbnailLink,\n      parents: file.parents,\n      path: '', // Will be calculated later\n      provider: 'google-drive' as const\n    }));\n\n    return {\n      files,\n      nextPageToken: data.nextPageToken\n    };\n  }\n\n  /**\n   * Download a file from Google Drive\n   */\n  async downloadFile(fileId: string): Promise<Blob> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated');\n    }\n\n    const response = await fetch(`${GOOGLE_DRIVE_API_BASE}/files/${fileId}?alt=media`, {\n      headers: {\n        'Authorization': `Bearer ${this.accessToken}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to download file: ${response.statusText}`);\n    }\n\n    return await response.blob();\n  }\n\n  /**\n   * Get file metadata\n   */\n  async getFileMetadata(fileId: string): Promise<CloudFile> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated');\n    }\n\n    const response = await fetch(\n      `${GOOGLE_DRIVE_API_BASE}/files/${fileId}?fields=id,name,mimeType,size,createdTime,modifiedTime,webViewLink,thumbnailLink,parents`,\n      {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to get file metadata: ${response.statusText}`);\n    }\n\n    const file = await response.json();\n\n    return {\n      id: file.id,\n      name: file.name,\n      mimeType: file.mimeType,\n      size: parseInt(file.size || '0'),\n      createdTime: file.createdTime,\n      modifiedTime: file.modifiedTime,\n      webViewLink: file.webViewLink,\n      thumbnailLink: file.thumbnailLink,\n      parents: file.parents,\n      path: '',\n      provider: 'google-drive'\n    };\n  }\n\n  /**\n   * Build full file paths by traversing parent folders\n   */\n  async buildFilePaths(files: CloudFile[]): Promise<CloudFile[]> {\n    // Create a map of folder IDs to folder names\n    const folderMap = new Map<string, string>();\n    \n    // First pass: collect all folders\n    for (const file of files) {\n      if (file.mimeType === 'application/vnd.google-apps.folder') {\n        folderMap.set(file.id, file.name);\n      }\n    }\n\n    // Second pass: build paths\n    const buildPath = (file: CloudFile): string => {\n      if (!file.parents || file.parents.length === 0) {\n        return file.name;\n      }\n\n      const parentId = file.parents[0];\n      const parentName = folderMap.get(parentId);\n\n      if (!parentName) {\n        return file.name;\n      }\n\n      // Recursively build path (simplified - doesn't handle deep nesting)\n      return `${parentName}/${file.name}`;\n    };\n\n    return files.map(file => ({\n      ...file,\n      path: buildPath(file)\n    }));\n  }\n\n  /**\n   * Revoke authentication token\n   */\n  async revokeAuth(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.accessToken) {\n        resolve();\n        return;\n      }\n\n      chrome.identity.removeCachedAuthToken({ token: this.accessToken }, () => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n          return;\n        }\n\n        this.accessToken = null;\n        resolve();\n      });\n    });\n  }\n}\n\n// Export singleton instance\nexport const googleDriveAPI = new GoogleDriveAPI();\n\n","/**\n * Living Nexus Archive - Microsoft OneDrive API Integration\n */\n\nimport type { CloudFile, AuthToken } from '../types';\n\nconst ONEDRIVE_API_BASE = 'https://graph.microsoft.com/v1.0';\nconst MICROSOFT_AUTH_ENDPOINT = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize';\nconst MICROSOFT_TOKEN_ENDPOINT = 'https://login.microsoftonline.com/common/oauth2/v2.0/token';\n\nexport class OneDriveAPI {\n  private accessToken: string | null = null;\n  private clientId: string = 'YOUR_MICROSOFT_CLIENT_ID'; // Will be configured\n\n  /**\n   * Authenticate with Microsoft OneDrive using OAuth 2.0\n   */\n  async authenticate(): Promise<AuthToken> {\n    const redirectUri = chrome.identity.getRedirectURL();\n    \n    const authUrl = new URL(MICROSOFT_AUTH_ENDPOINT);\n    authUrl.searchParams.append('client_id', this.clientId);\n    authUrl.searchParams.append('response_type', 'token');\n    authUrl.searchParams.append('redirect_uri', redirectUri);\n    authUrl.searchParams.append('scope', 'Files.Read.All offline_access');\n\n    return new Promise((resolve, reject) => {\n      chrome.identity.launchWebAuthFlow(\n        {\n          url: authUrl.toString(),\n          interactive: true\n        },\n        (responseUrl) => {\n          if (chrome.runtime.lastError || !responseUrl) {\n            reject(new Error(chrome.runtime.lastError?.message || 'Authentication failed'));\n            return;\n          }\n\n          // Parse access token from URL fragment\n          const params = new URLSearchParams(responseUrl.split('#')[1]);\n          const accessToken = params.get('access_token');\n          const expiresIn = parseInt(params.get('expires_in') || '3600');\n\n          if (!accessToken) {\n            reject(new Error('No access token received'));\n            return;\n          }\n\n          this.accessToken = accessToken;\n\n          resolve({\n            provider: 'onedrive',\n            accessToken,\n            expiresAt: Date.now() + expiresIn * 1000\n          });\n        }\n      );\n    });\n  }\n\n  /**\n   * Get all files from OneDrive\n   */\n  async getAllFiles(): Promise<CloudFile[]> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated. Call authenticate() first.');\n    }\n\n    const files: CloudFile[] = [];\n    let nextLink: string | undefined = `${ONEDRIVE_API_BASE}/me/drive/root/children`;\n\n    do {\n      const response = await this.fetchFiles(nextLink);\n      files.push(...response.files);\n      nextLink = response.nextLink;\n    } while (nextLink);\n\n    return files;\n  }\n\n  /**\n   * Fetch a page of files from OneDrive\n   */\n  private async fetchFiles(url: string): Promise<{ files: CloudFile[]; nextLink?: string }> {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': `Bearer ${this.accessToken}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`OneDrive API error: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n\n    const files: CloudFile[] = data.value.map((item: any) => ({\n      id: item.id,\n      name: item.name,\n      mimeType: item.file?.mimeType || 'application/vnd.ms-folder',\n      size: item.size || 0,\n      createdTime: item.createdDateTime,\n      modifiedTime: item.lastModifiedDateTime,\n      webViewLink: item.webUrl,\n      thumbnailLink: item.thumbnails?.[0]?.large?.url,\n      parents: item.parentReference ? [item.parentReference.id] : [],\n      path: item.parentReference?.path || '',\n      provider: 'onedrive' as const\n    }));\n\n    return {\n      files,\n      nextLink: data['@odata.nextLink']\n    };\n  }\n\n  /**\n   * Download a file from OneDrive\n   */\n  async downloadFile(fileId: string): Promise<Blob> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated');\n    }\n\n    // Get download URL\n    const metadataResponse = await fetch(\n      `${ONEDRIVE_API_BASE}/me/drive/items/${fileId}`,\n      {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      }\n    );\n\n    if (!metadataResponse.ok) {\n      throw new Error(`Failed to get file metadata: ${metadataResponse.statusText}`);\n    }\n\n    const metadata = await metadataResponse.json();\n    const downloadUrl = metadata['@microsoft.graph.downloadUrl'];\n\n    if (!downloadUrl) {\n      throw new Error('No download URL available');\n    }\n\n    // Download file\n    const fileResponse = await fetch(downloadUrl);\n\n    if (!fileResponse.ok) {\n      throw new Error(`Failed to download file: ${fileResponse.statusText}`);\n    }\n\n    return await fileResponse.blob();\n  }\n\n  /**\n   * Get file metadata\n   */\n  async getFileMetadata(fileId: string): Promise<CloudFile> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated');\n    }\n\n    const response = await fetch(\n      `${ONEDRIVE_API_BASE}/me/drive/items/${fileId}`,\n      {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to get file metadata: ${response.statusText}`);\n    }\n\n    const item = await response.json();\n\n    return {\n      id: item.id,\n      name: item.name,\n      mimeType: item.file?.mimeType || 'application/vnd.ms-folder',\n      size: item.size || 0,\n      createdTime: item.createdDateTime,\n      modifiedTime: item.lastModifiedDateTime,\n      webViewLink: item.webUrl,\n      thumbnailLink: item.thumbnails?.[0]?.large?.url,\n      parents: item.parentReference ? [item.parentReference.id] : [],\n      path: item.parentReference?.path || '',\n      provider: 'onedrive'\n    };\n  }\n\n  /**\n   * Recursively get all files including nested folders\n   */\n  async getAllFilesRecursive(folderId: string = 'root', basePath: string = ''): Promise<CloudFile[]> {\n    if (!this.accessToken) {\n      throw new Error('Not authenticated');\n    }\n\n    const files: CloudFile[] = [];\n    const url = `${ONEDRIVE_API_BASE}/me/drive/items/${folderId}/children`;\n\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': `Bearer ${this.accessToken}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`OneDrive API error: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n\n    for (const item of data.value) {\n      const file: CloudFile = {\n        id: item.id,\n        name: item.name,\n        mimeType: item.file?.mimeType || 'application/vnd.ms-folder',\n        size: item.size || 0,\n        createdTime: item.createdDateTime,\n        modifiedTime: item.lastModifiedDateTime,\n        webViewLink: item.webUrl,\n        thumbnailLink: item.thumbnails?.[0]?.large?.url,\n        parents: [folderId],\n        path: basePath ? `${basePath}/${item.name}` : item.name,\n        provider: 'onedrive'\n      };\n\n      files.push(file);\n\n      // If it's a folder, recursively get its contents\n      if (item.folder) {\n        const subFiles = await this.getAllFilesRecursive(item.id, file.path);\n        files.push(...subFiles);\n      }\n    }\n\n    return files;\n  }\n\n  /**\n   * Clear authentication\n   */\n  clearAuth(): void {\n    this.accessToken = null;\n  }\n}\n\n// Export singleton instance\nexport const oneDriveAPI = new OneDriveAPI();\n\n","/**\n * Living Nexus Archive - Background Service Worker\n * Handles API calls, file downloads, and migration orchestration\n */\n\nimport { googleDriveAPI } from '../api/google-drive';\nimport { oneDriveAPI } from '../api/onedrive';\nimport type { \n  ExtensionMessage, \n  ExtensionResponse, \n  MigrationSession, \n  MigrationTask,\n  MigrationStatus,\n  CloudFile,\n  CloudProvider\n} from '../types';\n\n// Active migration sessions\nconst activeSessions = new Map<string, MigrationSession>();\n\n/**\n * Handle messages from popup/content scripts\n */\nchrome.runtime.onMessage.addListener((\n  message: ExtensionMessage,\n  sender,\n  sendResponse: (response: ExtensionResponse) => void\n) => {\n  handleMessage(message).then(sendResponse);\n  return true; // Keep channel open for async response\n});\n\n/**\n * Main message handler\n */\nasync function handleMessage(message: ExtensionMessage): Promise<ExtensionResponse> {\n  try {\n    switch (message.type) {\n      case 'AUTHENTICATE':\n        return await handleAuthenticate(message.payload.provider);\n      \n      case 'GET_FILES':\n        return await handleGetFiles(message.payload.provider);\n      \n      case 'START_MIGRATION':\n        return await handleStartMigration(message.payload);\n      \n      case 'PAUSE_MIGRATION':\n        return await handlePauseMigration(message.payload.sessionId);\n      \n      case 'RESUME_MIGRATION':\n        return await handleResumeMigration(message.payload.sessionId);\n      \n      case 'CANCEL_MIGRATION':\n        return await handleCancelMigration(message.payload.sessionId);\n      \n      case 'GET_STATS':\n        return await handleGetStats();\n      \n      default:\n        return {\n          success: false,\n          error: `Unknown message type: ${message.type}`\n        };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error'\n    };\n  }\n}\n\n/**\n * Handle authentication request\n */\nasync function handleAuthenticate(provider: CloudProvider): Promise<ExtensionResponse> {\n  try {\n    let authToken;\n\n    if (provider === 'google-drive') {\n      authToken = await googleDriveAPI.authenticate();\n    } else if (provider === 'onedrive') {\n      authToken = await oneDriveAPI.authenticate();\n    } else {\n      throw new Error(`Unsupported provider: ${provider}`);\n    }\n\n    // Store auth token\n    await chrome.storage.local.set({\n      [`auth_${provider}`]: authToken\n    });\n\n    return {\n      success: true,\n      data: { provider, authenticated: true }\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Authentication failed'\n    };\n  }\n}\n\n/**\n * Handle get files request\n */\nasync function handleGetFiles(provider: CloudProvider): Promise<ExtensionResponse> {\n  try {\n    let files: CloudFile[];\n\n    if (provider === 'google-drive') {\n      files = await googleDriveAPI.getAllFiles();\n      files = await googleDriveAPI.buildFilePaths(files);\n    } else if (provider === 'onedrive') {\n      files = await oneDriveAPI.getAllFilesRecursive();\n    } else {\n      throw new Error(`Unsupported provider: ${provider}`);\n    }\n\n    return {\n      success: true,\n      data: { files, count: files.length }\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to get files'\n    };\n  }\n}\n\n/**\n * Handle start migration request\n */\nasync function handleStartMigration(payload: {\n  provider: CloudProvider;\n  files: CloudFile[];\n  settings: any;\n}): Promise<ExtensionResponse> {\n  try {\n    const sessionId = generateSessionId();\n    \n    const session: MigrationSession = {\n      id: sessionId,\n      provider: payload.provider,\n      status: 'scanning',\n      totalFiles: payload.files.length,\n      completedFiles: 0,\n      failedFiles: 0,\n      totalSize: payload.files.reduce((sum, f) => sum + f.size, 0),\n      downloadedSize: 0,\n      startTime: Date.now(),\n      tasks: payload.files.map(file => ({\n        id: generateTaskId(),\n        file,\n        status: 'idle',\n        progress: 0,\n        startTime: Date.now()\n      }))\n    };\n\n    activeSessions.set(sessionId, session);\n\n    // Start migration in background\n    startMigrationProcess(session, payload.settings);\n\n    return {\n      success: true,\n      data: { sessionId, session }\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to start migration'\n    };\n  }\n}\n\n/**\n * Start the actual migration process\n */\nasync function startMigrationProcess(session: MigrationSession, settings: any) {\n  session.status = 'downloading';\n\n  for (const task of session.tasks) {\n    // Check if migration should stop\n    if (session.status !== 'downloading') {\n      break;\n    }\n\n    try {\n      await downloadAndSaveFile(task, session, settings);\n      session.completedFiles++;\n    } catch (error) {\n      task.status = 'error';\n      task.error = error instanceof Error ? error.message : 'Download failed';\n      session.failedFiles++;\n    }\n\n    // Notify progress\n    chrome.runtime.sendMessage({\n      type: 'UPDATE_PROGRESS',\n      payload: { sessionId: session.id, session }\n    });\n  }\n\n  session.status = session.failedFiles > 0 ? 'error' : 'complete';\n  session.endTime = Date.now();\n\n  // Notify completion\n  chrome.runtime.sendMessage({\n    type: 'MIGRATION_COMPLETE',\n    payload: { sessionId: session.id, session }\n  });\n}\n\n/**\n * Download and save a single file\n */\nasync function downloadAndSaveFile(\n  task: MigrationTask,\n  session: MigrationSession,\n  settings: any\n) {\n  task.status = 'downloading';\n\n  let blob: Blob;\n\n  // Download from cloud\n  if (session.provider === 'google-drive') {\n    blob = await googleDriveAPI.downloadFile(task.file.id);\n  } else if (session.provider === 'onedrive') {\n    blob = await oneDriveAPI.downloadFile(task.file.id);\n  } else {\n    throw new Error(`Unsupported provider: ${session.provider}`);\n  }\n\n  // Determine local path\n  const localPath = determineLocalPath(task.file, settings);\n\n  // Download using Chrome Downloads API\n  const url = URL.createObjectURL(blob);\n  \n  const downloadId = await chrome.downloads.download({\n    url,\n    filename: localPath,\n    saveAs: false\n  });\n\n  // Wait for download to complete\n  await waitForDownload(downloadId);\n\n  task.status = 'complete';\n  task.progress = 100;\n  task.endTime = Date.now();\n  task.localPath = localPath;\n\n  session.downloadedSize += task.file.size;\n\n  // Clean up blob URL\n  URL.revokeObjectURL(url);\n}\n\n/**\n * Determine local file path based on settings\n */\nfunction determineLocalPath(file: CloudFile, settings: any): string {\n  const baseDir = settings.downloadLocation || 'LivingNexusArchive';\n  \n  if (settings.organizeByType) {\n    const category = categorizeFile(file.mimeType);\n    return `${baseDir}/${category}/${file.name}`;\n  }\n  \n  if (settings.preserveFolderStructure) {\n    return `${baseDir}/${file.path}`;\n  }\n  \n  return `${baseDir}/${file.name}`;\n}\n\n/**\n * Categorize file by MIME type\n */\nfunction categorizeFile(mimeType: string): string {\n  if (mimeType.startsWith('image/')) return 'Photos';\n  if (mimeType.startsWith('video/')) return 'Videos';\n  if (mimeType.startsWith('audio/')) return 'Music';\n  if (mimeType.includes('pdf') || mimeType.includes('document')) return 'Documents';\n  if (mimeType.includes('zip') || mimeType.includes('archive')) return 'Archives';\n  return 'Other';\n}\n\n/**\n * Wait for a download to complete\n */\nfunction waitForDownload(downloadId: number): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const listener = (delta: chrome.downloads.DownloadDelta) => {\n      if (delta.id !== downloadId) return;\n\n      if (delta.state?.current === 'complete') {\n        chrome.downloads.onChanged.removeListener(listener);\n        resolve();\n      } else if (delta.state?.current === 'interrupted') {\n        chrome.downloads.onChanged.removeListener(listener);\n        reject(new Error('Download interrupted'));\n      }\n    };\n\n    chrome.downloads.onChanged.addListener(listener);\n  });\n}\n\n/**\n * Handle pause migration\n */\nasync function handlePauseMigration(sessionId: string): Promise<ExtensionResponse> {\n  const session = activeSessions.get(sessionId);\n  \n  if (!session) {\n    return { success: false, error: 'Session not found' };\n  }\n\n  session.status = 'paused';\n\n  return { success: true, data: { session } };\n}\n\n/**\n * Handle resume migration\n */\nasync function handleResumeMigration(sessionId: string): Promise<ExtensionResponse> {\n  const session = activeSessions.get(sessionId);\n  \n  if (!session) {\n    return { success: false, error: 'Session not found' };\n  }\n\n  session.status = 'downloading';\n  \n  // Resume migration process\n  const settings = await chrome.storage.local.get('settings');\n  startMigrationProcess(session, settings.settings);\n\n  return { success: true, data: { session } };\n}\n\n/**\n * Handle cancel migration\n */\nasync function handleCancelMigration(sessionId: string): Promise<ExtensionResponse> {\n  const session = activeSessions.get(sessionId);\n  \n  if (!session) {\n    return { success: false, error: 'Session not found' };\n  }\n\n  session.status = 'error';\n  session.endTime = Date.now();\n  activeSessions.delete(sessionId);\n\n  return { success: true, data: { session } };\n}\n\n/**\n * Handle get stats request\n */\nasync function handleGetStats(): Promise<ExtensionResponse> {\n  // Get stats from storage\n  const data = await chrome.storage.local.get(['cloudStats', 'localStats']);\n\n  return {\n    success: true,\n    data: {\n      cloud: data.cloudStats || {},\n      local: data.localStats || {}\n    }\n  };\n}\n\n/**\n * Generate unique session ID\n */\nfunction generateSessionId(): string {\n  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Generate unique task ID\n */\nfunction generateTaskId(): string {\n  return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n// Log that service worker is loaded\nconsole.log('Living Nexus Archive - Service Worker loaded');\n\n"],"names":[],"mappings":"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"}